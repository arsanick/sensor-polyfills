<!DOCTYPE html>
<html lang="en">
<head>
<title>Sensor Data</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
      font-size: 12px;
    }
    #check, #x {
      font-size: 5em;
      display: block;
    }
    @media (max-width: 600px) {
      #check, #x {
        font-size: 3em;
      }
    }
    #geoBtn {
      display: none; /* Hide the button by default; This botton is not appearing when permission is denied */
    }
  </style>
</head>
<body>

<h1>Sensor Data</h1>

<h2>Geolocation Data</h2>

<div id="geolocation-data">
    <p>Latitude: <span id="latitude">0</span></p>
    <p>Longitude: <span id="longitude">0</span></p>
</div>

<button id="geoBtn" onclick="handlePermission()">Get Geolocation</button>

<h2>Absolute Orientation Data</h2>

<div id="orientation-data">
  <p>Absolute Orientation Quaternion:</p>
  <p>Roll: <span id="roll">0</span></p>
  <p>Pitch: <span id="pitch">0</span></p>
  <p>Yaw: <span id="yaw">0</span></p>
  <div id="status"></div>
</div>

<script type="module">
// Import the AbsoluteOrientationSensor class
import { AbsoluteOrientationSensor } from './src/motion-sensors.js'; // Replace with the actual path to your implementation

// Function to convert quaternion to Euler angles in degrees
function quaternionToEuler(q) {
  const x = q[0], y = q[1], z = q[2], w = q[3];

  // Roll (x-axis rotation)
  const roll = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y));

  // Pitch (y-axis rotation)
  let pitch = Math.asin(2 * (w * y - z * x));

  // Yaw (z-axis rotation)
  let yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z));

  // Convert radians to degrees
  const rollDeg = roll * 180 / Math.PI;
  const pitchDeg = pitch * 180 / Math.PI;
  const yawDeg = yaw * 180 / Math.PI;

  return { roll: rollDeg, pitch: pitchDeg, yaw: yawDeg };
}

// Options for the AbsoluteOrientationSensor
const options = { frequency: 60, referenceFrame: "device" };

// Create a new AbsoluteOrientationSensor instance
const sensor = new AbsoluteOrientationSensor(options);

// Event listener for reading the sensor data
sensor.addEventListener("reading", () => {
  // Access the quaternion data
  const quaternion = sensor.quaternion;
  // Convert quaternion to Euler angles
  const eulerAngles = quaternionToEuler(quaternion);
  // Update the orientation data on the page
  document.querySelector('#roll').textContent = eulerAngles.roll.toFixed(2);
  document.querySelector('#pitch').textContent = eulerAngles.pitch.toFixed(2);
  document.querySelector('#yaw').textContent = eulerAngles.yaw.toFixed(2);

  // Call the function to update the status graphics
  updateStatusGraphics(eulerAngles.yaw);
});

// Event listener for handling errors
sensor.addEventListener("error", (event) => {
  if (event.error.name === "NotReadableError") {
    console.log("Sensor is not available.");
  }
});

// Start the orientation sensor
sensor.start();

// Function to update the status graphics based on the yaw angle
function updateStatusGraphics(yaw) {
  const statusElement = document.getElementById('status');
  statusElement.innerHTML = ''; // Clear previous content
  if (yaw > -20 && yaw < 20) {
    const checkElement = document.createElement('span');
    checkElement.className = 'check';
    checkElement.textContent = '✔️';
    statusElement.appendChild(checkElement);
  } else {
    const xElement = document.createElement('span');
    xElement.className = 'x';
    xElement.textContent = '❌';
    statusElement.appendChild(xElement);
  }
}

// Geolocation code using the button
function handlePermission() {
  navigator.permissions.query({ name: "geolocation" }).then((result) => {
    if (result.state === "granted") {
      report(result.state);
      geoBtn.style.display = "none";
      getLocation();
    } else if (result.state === "prompt") {
      report(result.state);
      geoBtn.style.display = "none";
      getLocation();
    } else if (result.state === "denied") {
      report(result.state);
      geoBtn.style.display = "inline";
    }
    result.addEventListener("change", () => {
      //report(result.state);
      handlePermission(); // Suggestion to make the button appear. Call handlePermission again to update the button visibility
    });
  });
}

function report(state) {
  console.log(`Permission ${state}`);
}

function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(successCallback, errorCallback);
  } else {
    console.error("Geolocation is not available.");
  }
}

function successCallback(position) {
  document.querySelector('#latitude').textContent = position.coords.latitude.toFixed(2);
  document.querySelector('#longitude').textContent = position.coords.longitude.toFixed(2);

  // Call the function to update the status graphics with the yaw angle from the sensor
  // Check if the sensor and quaternion are defined before converting
  if (sensor && sensor.quaternion) {
    // Call the function to update the status graphics with the yaw angle from the sensor
    updateStatusGraphics(quaternionToEuler(sensor.quaternion).yaw);
  } else {
    console.error("Sensor or quaternion is not defined.");
  }
}

function errorCallback(error) {
  alert(`ERROR(${error.code}): ${error.message}`);
}

// Request geolocation permission when the page loads
handlePermission();
</script>

</body>
</html>